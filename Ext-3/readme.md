## 1. Анализ текущей архитектуры: проблемы и риски

### 1.1. Точка входа: сервис **ins-product-aggregator**
1. **Синхронные REST-запросы ко всем страховым компаниям**. При каждом запросе (или раз в 15 мин для core-app и раз в сутки для ins-comp-settlement) сервис ins-product-aggregator делает последовательные/параллельные вызовы к 5 страховым компаниям.
    - **Риск**: Если хотя бы одна из компаний «подвисает» или даёт долгий ответ, вся цепочка блокируется.
    - **Риск**: С добавлением 5 новых компаний проблема усугубится (в два раза больше внешних вызовов).

2. **Локальное кэширование продуктов и тарифов** в core-app и ins-comp-settlement:
    - **Риск рассинхронизации**: если обновления в агрегаторе (включая новые продукты или изменения тарифов) приходят чаще, чем сервисы (core-app и ins-comp-settlement) успевают их забирать (15 минут / сутки). Возможно, пользователи не видят актуальные цены и тарифы.
    - **Риск перегрузки**: чем чаще будут «сливать» полные данные о продуктах, тем выше нагрузка на ins-product-aggregator и внешние API.

### 1.2. Взаимодействие **ins-comp-settlement** → **core-app**
1. **Раз в сутки** ins-comp-settlement дергает core-app, чтобы получить список оформленных страховок.
    - **Риск**: Если к моменту запроса core-app недоступен, то формирование отчёта сорвётся, придётся делать повторные запросы и т.п.
    - **Риск**: Высокая нагрузка при «массовом» синхронном запросе большого объёма данных (особенно если объём оформленных страховок по всем регионам РФ большой).

### 1.3. Ошибки взаимодействия и задержки
1. **Ошибка из одного сервиса тянет сбой у другого** (цепочка REST-вызовов блокируется). Например, если aggregator не ответил core-app за нужное время, core-app возвращает пользователю ошибку. То же с ins-comp-settlement.
2. **Сложно отслеживать потоки данных** в случае сбоя. Нет явного «лога событий», всё завязано на периодический pull-цикл.

### 1.4. Увеличение количества страховых компаний
1. С ростом количества компаний до 10 (а возможно и более в будущем) — **рост времени ожидания** синхронного REST (особенно если делать «под капотом» вызовы к каждому провайдеру).
2. Более частые сбои или задержки от внешних API.

Таким образом, текущее решение (синхронные вызовы, периодический pull-цикл) при возросшем количестве партнёров грозит ещё большими задержками, ошибками и рассинхронизацией данных.

---

## 2. Предложения по улучшению (Event-Driven подход)

По условию:
> «Не меняя декомпозицию функциональности между сервисами, подумай, какие взаимодействия стоит переделать на Event-Streaming».

То есть сервисы **core-app** и **ins-comp-settlement** по-прежнему занимаются своими функциями (core-app — оформление, ins-comp-settlement — взаиморасчёты), но мы меняем **способ обмена данными**.

### 2.1. Переход на Event-Streaming для обновления продуктовых данных
1. **ins-product-aggregator** будет по событиям **получать/обновлять** тарифы и продукты страховых компаний.
2. **core-app** и **ins-comp-settlement** **подписываются** (subscribe) на соответствующие топики / очереди.
    - Вместо периодических pull-запросов они получают **push-события** об изменениях продуктов и тарифов.
    - При получении события сервис обновляет **локальный кэш** (реплику). Это происходит почти «в реальном времени», а не раз в 15 минут/сутки.
    - Таким образом, при росте количества страховых компаний всё равно основная нагрузка ложится на ins-product-aggregator, но **синхронных блокирующих** вызовов от core-app больше нет.

**Плюсы**:
- Уменьшение риска таймаутов: core-app/ins-comp-settlement не зависят от «прямых» вызовов внешних API.
- Система становится более «слабосвязанной»: сбой одной интеграции не ломает целиком цепочку.

### 2.2. Переход на Event-Driven для передачи «списка оформленных страховок»
1. Вместо того чтобы ins-comp-settlement «ходил» раз в сутки в core-app через REST для получения списка всех оформленных договоров, сам **core-app** может генерировать события типа «Полис Оформлен» («PolicyCreatedEvent», «NewInsuranceSoldEvent») при каждом факте оформления.
2. **ins-comp-settlement** (и любые другие заинтересованные сервисы) просто подписывается на эти события.
    - После получения события ins-comp-settlement сохраняет нужную информацию для дальнейших расчётов (например, во внутреннем хранилище).
    - Раз в сутки, когда ins-comp-settlement формирует реестр, у него уже есть все данные о проданных полисах (сложенные в локальную базу). Нет необходимости «поднимать» тяжёлый REST на сутки.
3. Если нужна «полная выборка» по датам (на случай сверки или восстановления), ins-comp-settlement может обратиться к core-app по REST (или GraphQL) _лишь как запасной вариант_, а не как обязательный суточный сценарий.

**Плюсы**:
- Устранение критической зависимости от REST-запроса «в нужное время».
- Лучший контроль за потоком данных (у ins-comp-settlement будут все оформившиеся полисы практически онлайн).
- Меньше вероятность «завалить» core-app тяжелым запросом на миллион записей.

### 2.3. Transactional Outbox

да, паттерн **Transactional Outbox** целесообразно использовать, т.к. у нас важные **финансовые** операции, и потеря сообщений недопустима. Таким образом мы получим:
- **Надёжную** гарантированную доставку событий,
- Отсутствие рассинхронизации между фактом вставки в БД и отправкой события.

1. **core-app** при создании новой страховки записывает информацию о полисе. Тут же фиксирует событие «полис создан» в Outbox-таблице.
2. Фоновый «Publisher» процесс поднимает эту запись и отправляет сообщение в брокер (RebbitMQ).
3. **ins-comp-settlement** (и другие) подписаны на события «PolicyCreatedEvent».
4. Аналогичное поведение может быть и у **ins-product-aggregator**, когда он обновляет данные о продуктах у себя.

---

## 3. Итоговое решение (концептуально)

1. **ins-product-aggregator**:
    - При любом изменении (добавлении/удалении продукта) — сохраняет событие в Outbox → публикует в брокер (RebbitMQ).
    - (Опционально) всё ещё предоставляет REST API для «срочного» получения продуктового каталога, если нужно.

2. **core-app**:
    - Подписывается на события об изменениях в тарифах / продуктах (из RebbitMQ). Обновляет у себя локальную реплику.
    - При **оформлении новой страховки** в core-app:
        - Пишет запись в свою БД.
        - Записывает событие «InsurancePolicyCreated» в Outbox.
        - Отправляет это событие в брокер.
    - В результате нет необходимости ходить в aggregator за актуальной ценой прямо во время оформления (или, если нужно уточнение в реальном времени — это отдельный REST, но **обычные** кейсы будут закрываться локальным кэшем).

3. **ins-comp-settlement**:
    - Подписывается на события **InsurancePolicyCreated** (или обновления статуса) и **ProductUpdated**.
    - Сохраняет нужные данные (полис, тарифы) в локальную базу (или кэш).
    - Раз в сутки формирует отчёт по уже имеющейся у него инфе, не делая больших синхронных REST-запросов.

4. **Брокер сообщений / Event Streaming** RabbitMQ — **точка «центр»** для асинхронных взаимодействий и обмена событиями.

---