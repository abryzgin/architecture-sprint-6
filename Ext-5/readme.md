## 1. Анализ текущего REST API

В API сервиса `client-info` есть три основных ресурса:

1. **`GET /clients/{id}`**
    - Возвращает _объект клиента_ (`Client`) с полями: `id`, `name`, `age`.

2. **`GET /clients/{id}/documents`**
    - Возвращает список документов (`Document[]`) для данного клиента. Поля документа: `id`, `type`, `number`, `issueDate`, `expiryDate`.

3. **`GET /clients/{id}/relatives`**
    - Возвращает список родственников (`Relative[]`) клиента. Поля: `id`, `relationType`, `name`, `age`.

При использовании REST возникает две основные проблемы:
- Для **одного** клиентского сценария может потребоваться **несколько** вызовов (взять **сразу** и клиента, и документы, и родственников).
- Если предоставить один ресурс, который возвращает _абсолютно все поля_ клиента (а их до 500), мы рискуем передавать избыточную информацию, замедляя взаимодействие.

**GraphQL** помогает решить обе проблемы:
- Позволяет в **одном запросе** получить как клиента, так и связанные с ним объекты, **выбрав** ровно те поля, которые нужны конкретному потребителю.

---

## 2. Проектирование эквивалентной схемы GraphQL

Ниже — пример **SDL** (Schema Definition Language) для GraphQL, отражающий те же сущности, что есть в Swagger:

```graphql
# Точка входа в GraphQL-приложение
schema {
  query: Query
}

# Корневой тип запросов (Query)
type Query {
  # Позволяет получить данные конкретного клиента
  # вместе с любыми нужными полями (id, documents, relatives и т.д.)
  client(id: ID!): Client
}

# Описание типа "Клиент"
type Client {
  id: ID!
  name: String
  age: Int
  
  # Связанные документы (можно запрашивать только при необходимости)
  documents: [Document]
  
  # Связанные родственники (также по желанию)
  relatives: [Relative]
}

# Документы клиента
type Document {
  id: ID!
  type: String
  number: String
  issueDate: String
  expiryDate: String
}

# Родственники клиента
type Relative {
  id: ID!
  relationType: String
  name: String
  age: Int
}
```

### 2.1. Ключевые моменты схемы

1. **`Query.client(id: ID!)`**
    - Главная точка получения информации о клиенте.
    - При запросе мы **можем** в GraphQL-запросе указать, какие поля у клиента хотим (например, `name`, `age`) и нужны ли нам `documents` или `relatives`.

2. **Вложенные связи** (`Client.documents`, `Client.relatives`)
    - Если **нужны** документы, мы запрашиваем их явно в GraphQL-запросе. Если **не нужны**, мы пропускаем это поле и тем самым не тратим трафик и ресурсы на их извлечение.

3. **Разделения на “/documents” и “/relatives”** больше нет на уровне endpoint’ов — _всё_ уходит в единый гибкий GraphQL endpoint (часто `/graphql`).
    - При этом, при желании, **можно** добавить отдельные запросы (queries) для документов, если есть сценарии, где документы нужны **без** данных о клиенте. Но самый популярный подход — вложенные поля.

---

Итог: переход на GraphQL значительно **уменьшает RPS** (меньше обращений к сервису `client-info`), позволяет **не передавать «лишние» поля**, и даёт удобную гибкую схему для _самых_ разных сценариев отображения и обработки клиентских данных.